1.时间和空间复杂度的分析

为什么要进行复杂度分析 有人提出过事后统计法这个概念但是这种方法有局限性

1.测试结果太依赖测试环境 如CPU性能等
2.测试结果受数据规模的影响很大比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快.
**因此我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率问题
这就是时间空间复杂度

======================================================
***大O复杂度表示法所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正正比

T(n) = O(f(n)); T(n)表示代码的时间，n表示数据的规模的大小f(n)表示每行代码执行次数的
总和。O表示两者成正比


*算法的执行效率就是讲 ------>就是算法代码的执行时间
*分析如下代码：为了粗略计算首先设置一个单位时间unit_time
*1，3都是一个单位时间
*4，5是n个单位时间
***因此在这段代码执行的时间总和为（2n+2）个单位时间
总结*****多有代码的执行时间T(n)与每行代码的执行次数成正比
1 int cal(int n) {
2     int sum = 0;
3    int i = 1;
4for (; i <= n; ++i) {
5     sum = sum + i;
6   }
7   return sum;
8 }
===========================================
根据上面所学分析下面的代码总执行效率
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
2，3，4都是一个单位时间5，6是n各单位时间7，8是n平方个单位时间
因此总和为3+2n+2n*
=============================================
但是大O时间复杂度实际上并不具体表示代码执行的真正实践，

****而是表示代码执行时间随数据规模增长的变化趋势---->渐进时间复杂度(时间复杂度)

****如果用大O表示法表示前面的两段代码的时间复杂度 T(n)=O(n); T(n)=O(n平方)
**就像刚才的所说大O时间复杂度表示的是代码执行时间是随数据规模增长变化的 因此
在大O时间复杂度中公式中的低阶，常量和，系数是并不看作可以左右时间复杂度的趋势
因此只需要关注最大量级那个就可以了。
分析技巧：
1.我们只需要关注代码执行次数最多的那一段代码
实例：
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
时间复杂度为O(n);
=========================================
2.加法法则 ：总复杂度等于量级最大的那段代码的复杂度
实例：
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
算法时间复杂度为：O(n*2)
=============================================
乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
实例：
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
时间复杂度是：这个可以看到cal()函数调用了f()函数而且被动用在循环体里面
这个的时间复杂度为O(n*n)
==============================================
常见的复杂度量级
1.常量阶 O(1)
2.对数阶 O(logn)
3.线性阶 O(n)
4.线性对数阶 O(nlogn)
5.平方阶 O(n*2)~O(n*k)
6.指数阶 O(2*n)
7.阶乘阶 O(n!)
8什么是对数？
如果a的x次方等于N（a>0，且a≠1）那么数x叫做以a为底N的对数（logarithm）
记作 其中，a叫做对数的底数，N叫做真数，x叫做“以a为底N的对数”。
9.什么是阶乘
n! = 1*2*3*4......*n
10.上面的复杂度量级分为多项式量级和非多项式量级
11非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限制的增长
是非常低效的算法。
================================================
O(1)什么样子的代码是？
答案是一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行代码
其时间复杂度都是O(1)
=================================================
O(logn)和O(nlogn)
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
思路分析：2*1+2*2.....+2*k = n
k=log2*n
这是一个对数阶的O(logn)代码
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
k=log3*n
这两个最终的时间复杂度都是O(logn)

因为：我们都知道对数之间时刻一互相转换的
 因为log3*2 X log2*n = log3*n
这是一个换底公式
因为在大O标记复杂度的时候可以忽略系数 进而可以忽略底因此统一表示为
O(logn)
O(nlogn)表示为如果如果把一个O(logn)的时间复杂度的代码循环O(n)次那么
根据乘法法则那么最终的复杂度就是O(nlogn)
========================================================
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
从代码中可以看出，m 和 n 是表示两个数据规模。我们无法看出来谁的量级大
不能简单地利用加法法则进行省略 所以最终的复杂度就是O(m+n)

O(m * n)相应的也会出现同上面的道理
===========================================================
============================================================
空间复杂度
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
如对上面的代码进行分析 第二行我们定义了一个变量i这样就是使我们申请了一个存储空间
i但是是常数阶的可以省略 第三行有一个数组那么系统会分配n个内存空间因此这段代码的
空间复杂度就是O(n)
========================================================
常见的空间复杂度就是O(1) O(n) O(n*2)
++++++++++++++++++++++++++++++++++++++++++++++++++++
总结
++++++++++++++++++++++++++++++++++++++++++++++++++++
总结
一、什么是复杂度分析？
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
二、为什么要进行复杂度分析？
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
三、如何进行复杂度分析？
1.大O表示法
1）来源
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
2）特点
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
2.复杂度分析法则
1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
四、常用的复杂度级别？
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)（指数阶）、O(n!)（阶乘阶）
五、如何掌握好复杂度分析方法？
复杂度分析关键在于多练，所谓孰能生巧。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
